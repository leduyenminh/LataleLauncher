spring.application.name=launcher-service
# Launcher service runtime configuration (ports, data sources, cache, auth, fallbacks).

server.port=${PORT:4000}
# Configuration for the gRPC server connection
grpc.client.global.address=${GRPC_SERVER_ADDRESS:static://localhost:9001}
grpc.client.global.enableKeepAlive=true
grpc.client.global.keepAliveWithoutCalls=true

# Enable heap dump on OutOfMemoryError
spring.jvm.args=-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/latale/heapdumps

spring.datasource.url=${DB_URL:jdbc:mariadb://localhost:3306/latale?createDatabaseIfNotExist=true}
spring.datasource.username=${DB_USER:root}
spring.datasource.password=${DB_PASSWORD:root}

spring.jpa.database-platform=org.hibernate.dialect.MariaDBDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MariaDBDialect

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

logging.level.org.hibernate.orm.jdbc.bind=TRACE
# Let Spring Boot initialize schema.sql & data.sql
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
spring.jpa.properties.hibernate.generate_statistics=true
# Lazy loading and N+1 problem mitigation
spring.jpa.properties.hibernate.default_batch_fetch_size=10

# Second-level cache
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.internal.JCacheRegionFactory
hibernate.javax.cache.provider=org.ehcache.jsr107.EhcacheCachingProvider
hibernate.cache.provider_configuration_file_resource_path=classpath:ehcache.xml

# Query cache
spring.jpa.properties.hibernate.cache.use_query_cache=true

# Batch processing
spring.jpa.properties.hibernate.jdbc.batch_size=30
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# SQL script to initialize database with some data
#spring.sql.init.data-locations=classpath:data.sql
# DB_TYPE=mariaDB

#Kafka
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.ByteArraySerializer

#Spring Security
logging.level.org.springframework.security=TRACE

# Redis properties
spring.redis.host=${REDIS_HOST:redis}
spring.redis.port=${REDIS_PORT:6379}
spring.cache.type=redis


#lIQUIBASE
spring.liquibase.change-log=classpath:liquidbase/lataleMigration.xml
liquibase.sql.logLevel: FINE

#JWT 
jwt.secret=${JWT_SECRET:MySuperSecureJwtSecretKeyForHS256_123456}

launcher.servers.defaults[0].name=Elysium
launcher.servers.defaults[0].status=online
launcher.servers.defaults[0].population=High
launcher.servers.defaults[0].ping=42
launcher.servers.defaults[1].name=Aurora
launcher.servers.defaults[1].status=online
launcher.servers.defaults[1].population=Medium
launcher.servers.defaults[1].ping=58
launcher.servers.defaults[2].name=Shadowfall
launcher.servers.defaults[2].status=maintenance
launcher.servers.defaults[2].population=Low
launcher.servers.defaults[2].ping=120

#resilient4j
resilience4j.circuitbreaker.instances.inventoryService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.inventoryService.slidingWindowSize=5
resilience4j.circuitbreaker.instances.inventoryService.minimumNumberOfCalls=3
resilience4j.circuitbreaker.instances.inventoryService.failureRateThreshold=50
resilience4j.circuitbreaker.instances.inventoryService.waitDurationInOpenState=10s
resilience4j.circuitbreaker.instances.inventoryService.permittedNumberOfCallsInHalfOpenState=2
resilience4j.circuitbreaker.instances.inventoryService.automaticTransitionFromOpenToHalfOpenEnabled=true

resilience4j.timelimiter.instances.inventoryService.timeoutDuration=2s


